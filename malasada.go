package malasada

import (
	"bytes"
	"debug/elf"
	_ "embed"
	"encoding/binary"
	"errors"
	"fmt"
	"os"
)

// Arch is a linux architecture supported by malasada.
type Arch int

const (
	ArchUnknown Arch = iota
	ArchLinuxAMD64
	ArchLinuxARM64
)

func (a Arch) String() string {
	switch a {
	case ArchLinuxAMD64:
		return "linux/amd64"
	case ArchLinuxARM64:
		return "linux/arm64"
	default:
		return "unknown"
	}
}

func archFromELFMachine(m elf.Machine) (Arch, error) {
	switch m {
	case elf.EM_X86_64:
		return ArchLinuxAMD64, nil
	case elf.EM_AARCH64:
		return ArchLinuxARM64, nil
	default:
		return ArchUnknown, fmt.Errorf("unsupported ELF machine %v", m)
	}
}

var (
	errBadELF = errors.New("bad ELF")
)

// ConvertSharedObject reads a Linux ELF shared object from soPath, patches it to
// call exportName as the process entrypoint, and wraps it with the stage0 loader
// to produce an executable PIC .bin blob.
func ConvertSharedObject(soPath string, exportName string) ([]byte, error) {
	if exportName == "" {
		return nil, fmt.Errorf("export name is required")
	}
	so, err := os.ReadFile(soPath)
	if err != nil {
		return nil, err
	}

	arch, patchedSO, err := patchSOToCallExport(so, exportName)
	if err != nil {
		return nil, err
	}

	stage0, err := buildStage0(arch)
	if err != nil {
		return nil, err
	}
	if err := patchStage0PayloadLen(stage0, uint64(len(patchedSO))); err != nil {
		return nil, err
	}

	out := make([]byte, 0, len(stage0)+len(patchedSO))
	out = append(out, stage0...)
	out = append(out, patchedSO...)
	return out, nil
}

// -----------------------------
// stage0 build + patching
// -----------------------------

var msdaMagic = []byte("MALASADA")

//go:generate go run ./internal/stage0/genstage0 -out internal/stage0

// Prebuilt stage0 blobs (generated by `go generate`). These are embedded so the
// CLI can convert .so -> .bin without needing zig at runtime.
//
// IMPORTANT: Always copy before mutating; embed-backed bytes may live in
// read-only memory.
//
//go:embed internal/stage0/stage0_linux_amd64.bin
var stage0LinuxAMD64Prebuilt []byte

//go:embed internal/stage0/stage0_linux_arm64.bin
var stage0LinuxARM64Prebuilt []byte

func patchStage0PayloadLen(stage0 []byte, payloadLen uint64) error {
	// The stage0 linker script forces the msda header to the end of the extracted
	// .text. We enforce that invariant so we can append the payload bytes directly
	// after the header.
	const headerSize = 8 + 4 + 4 + 8
	if len(stage0) < headerSize {
		return fmt.Errorf("stage0 too small")
	}

	off := bytes.LastIndex(stage0, msdaMagic)
	if off < 0 {
		return fmt.Errorf("stage0 missing msda header")
	}
	if off+headerSize != len(stage0) {
		return fmt.Errorf("stage0 msda header is not at end (off=%d len=%d)", off, len(stage0))
	}

	// payload_len is at offset 16 from magic start.
	binary.LittleEndian.PutUint64(stage0[off+16:], payloadLen)
	return nil
}

func buildStage0(arch Arch) ([]byte, error) {
	var prebuilt []byte
	switch arch {
	case ArchLinuxAMD64:
		prebuilt = stage0LinuxAMD64Prebuilt
	case ArchLinuxARM64:
		prebuilt = stage0LinuxARM64Prebuilt
	default:
		return nil, fmt.Errorf("unsupported arch %v", arch)
	}
	if len(prebuilt) == 0 {
		return nil, fmt.Errorf("missing embedded stage0 for %v (run `go generate ./...`)", arch)
	}
	stage0 := make([]byte, len(prebuilt))
	copy(stage0, prebuilt)
	return stage0, nil
}

// -----------------------------
// .so patching (call export)
// -----------------------------

const (
	elf64HeaderSize = 64
	elf64PhdrSize   = 56

	ptLoad    = 1
	ptDynamic = 2
	ptNote    = 4

	ptGnuEhFrame = 0x6474e550
)

const (
	pfX = 0x1
	pfW = 0x2
	pfR = 0x4
)

const (
	dtNull   = 0
	dtFlags1 = 0x6ffffffb
)

const (
	df1Pie = 0x08000000
)

type elf64Ehdr struct {
	ident      [16]byte
	typ        uint16
	machine    uint16
	version    uint32
	entry      uint64
	phoff      uint64
	shoff      uint64
	flags      uint32
	ehsize     uint16
	phentsize  uint16
	phnum      uint16
	shentsize  uint16
	shnum      uint16
	shstrndx   uint16
	_entryOff  int
	_phoffOff  int
	_phnumOff  int
	_phentsOff int
}

type elf64Phdr struct {
	typ    uint32
	flags  uint32
	off    uint64
	vaddr  uint64
	paddr  uint64
	filesz uint64
	memsz  uint64
	align  uint64

	fileOff int // where this phdr starts in the file
}

func parseELF64Header(b []byte) (*elf64Ehdr, error) {
	if len(b) < elf64HeaderSize {
		return nil, errBadELF
	}
	var h elf64Ehdr
	copy(h.ident[:], b[:16])
	if h.ident[0] != 0x7f || h.ident[1] != 'E' || h.ident[2] != 'L' || h.ident[3] != 'F' {
		return nil, errBadELF
	}
	if h.ident[4] != 2 { // ELFCLASS64
		return nil, fmt.Errorf("%w: not ELF64", errBadELF)
	}
	if h.ident[5] != 1 { // ELFDATA2LSB
		return nil, fmt.Errorf("%w: not little-endian", errBadELF)
	}
	h.typ = binary.LittleEndian.Uint16(b[16:18])
	h.machine = binary.LittleEndian.Uint16(b[18:20])
	h.version = binary.LittleEndian.Uint32(b[20:24])
	h.entry = binary.LittleEndian.Uint64(b[24:32])
	h.phoff = binary.LittleEndian.Uint64(b[32:40])
	h.shoff = binary.LittleEndian.Uint64(b[40:48])
	h.flags = binary.LittleEndian.Uint32(b[48:52])
	h.ehsize = binary.LittleEndian.Uint16(b[52:54])
	h.phentsize = binary.LittleEndian.Uint16(b[54:56])
	h.phnum = binary.LittleEndian.Uint16(b[56:58])
	h.shentsize = binary.LittleEndian.Uint16(b[58:60])
	h.shnum = binary.LittleEndian.Uint16(b[60:62])
	h.shstrndx = binary.LittleEndian.Uint16(b[62:64])

	h._entryOff = 24
	h._phoffOff = 32
	h._phentsOff = 54
	h._phnumOff = 56

	if h.ehsize != elf64HeaderSize {
		return nil, fmt.Errorf("%w: unexpected ehsize %d", errBadELF, h.ehsize)
	}
	if h.phentsize != elf64PhdrSize {
		return nil, fmt.Errorf("%w: unexpected phentsize %d", errBadELF, h.phentsize)
	}
	if h.phoff == 0 || h.phnum == 0 {
		return nil, fmt.Errorf("%w: missing program headers", errBadELF)
	}
	phEnd := h.phoff + uint64(h.phnum)*uint64(h.phentsize)
	if phEnd > uint64(len(b)) {
		return nil, fmt.Errorf("%w: phdrs outside file", errBadELF)
	}
	return &h, nil
}

func parseELF64Phdrs(b []byte, h *elf64Ehdr) ([]elf64Phdr, error) {
	out := make([]elf64Phdr, 0, h.phnum)
	off := int(h.phoff)
	for i := 0; i < int(h.phnum); i++ {
		p := b[off+i*elf64PhdrSize : off+(i+1)*elf64PhdrSize]
		ph := elf64Phdr{
			typ:     binary.LittleEndian.Uint32(p[0:4]),
			flags:   binary.LittleEndian.Uint32(p[4:8]),
			off:     binary.LittleEndian.Uint64(p[8:16]),
			vaddr:   binary.LittleEndian.Uint64(p[16:24]),
			paddr:   binary.LittleEndian.Uint64(p[24:32]),
			filesz:  binary.LittleEndian.Uint64(p[32:40]),
			memsz:   binary.LittleEndian.Uint64(p[40:48]),
			align:   binary.LittleEndian.Uint64(p[48:56]),
			fileOff: off + i*elf64PhdrSize,
		}
		out = append(out, ph)
	}
	return out, nil
}

func writeELF64Entry(b []byte, entry uint64) {
	binary.LittleEndian.PutUint64(b[24:32], entry)
}

func writeELF64Phdr(b []byte, ph elf64Phdr) {
	p := b[ph.fileOff : ph.fileOff+elf64PhdrSize]
	binary.LittleEndian.PutUint32(p[0:4], ph.typ)
	binary.LittleEndian.PutUint32(p[4:8], ph.flags)
	binary.LittleEndian.PutUint64(p[8:16], ph.off)
	binary.LittleEndian.PutUint64(p[16:24], ph.vaddr)
	binary.LittleEndian.PutUint64(p[24:32], ph.paddr)
	binary.LittleEndian.PutUint64(p[32:40], ph.filesz)
	binary.LittleEndian.PutUint64(p[40:48], ph.memsz)
	binary.LittleEndian.PutUint64(p[48:56], ph.align)
}

func alignUp(x, align uint64) uint64 {
	if align == 0 {
		return x
	}
	return (x + (align - 1)) &^ (align - 1)
}

func patchSOToCallExport(so []byte, exportName string) (Arch, []byte, error) {
	// Use debug/elf for symbol resolution (parsing only).
	f, err := elf.NewFile(bytes.NewReader(so))
	if err != nil {
		return ArchUnknown, nil, err
	}
	if f.Class != elf.ELFCLASS64 || f.Data != elf.ELFDATA2LSB {
		return ArchUnknown, nil, fmt.Errorf("unsupported ELF (need 64-bit little-endian)")
	}
	if f.Type != elf.ET_DYN {
		return ArchUnknown, nil, fmt.Errorf("expected ET_DYN (.so), got %v", f.Type)
	}

	arch, err := archFromELFMachine(f.Machine)
	if err != nil {
		return ArchUnknown, nil, err
	}

	dynSyms, err := f.DynamicSymbols()
	if err != nil {
		return ArchUnknown, nil, err
	}
	var exportVaddr uint64
	found := false
	for _, s := range dynSyms {
		if s.Name == exportName {
			exportVaddr = s.Value
			found = true
			break
		}
	}
	if !found {
		return ArchUnknown, nil, fmt.Errorf("export %q not found in .dynsym", exportName)
	}

	h, err := parseELF64Header(so)
	if err != nil {
		return ArchUnknown, nil, err
	}
	if elf.Type(h.typ) != elf.ET_DYN {
		return ArchUnknown, nil, fmt.Errorf("%w: not ET_DYN", errBadELF)
	}
	if elf.Machine(h.machine) != f.Machine {
		return ArchUnknown, nil, fmt.Errorf("%w: machine mismatch", errBadELF)
	}
	phdrs, err := parseELF64Phdrs(so, h)
	if err != nil {
		return ArchUnknown, nil, err
	}

	// Find a program header we can repurpose into a new executable PT_LOAD for the entry stub.
	phIdx := -1
	for i := range phdrs {
		if phdrs[i].typ == ptNote {
			phIdx = i
			break
		}
	}
	if phIdx < 0 {
		for i := range phdrs {
			if phdrs[i].typ == ptGnuEhFrame {
				phIdx = i
				break
			}
		}
	}
	if phIdx < 0 {
		return ArchUnknown, nil, fmt.Errorf("no suitable program header to repurpose (need PT_NOTE or PT_GNU_EH_FRAME)")
	}

	var maxVaddrEnd uint64
	var maxAlign uint64 = 0x1000
	var dynPh *elf64Phdr
	for i := range phdrs {
		ph := &phdrs[i]
		if ph.typ == ptLoad {
			end := ph.vaddr + ph.memsz
			if end > maxVaddrEnd {
				maxVaddrEnd = end
			}
			if ph.align > maxAlign {
				maxAlign = ph.align
			}
		}
		if ph.typ == ptDynamic {
			dynPh = ph
		}
	}
	if maxVaddrEnd == 0 {
		return ArchUnknown, nil, fmt.Errorf("%w: no PT_LOAD segments", errBadELF)
	}
	if dynPh == nil {
		return ArchUnknown, nil, fmt.Errorf("%w: no PT_DYNAMIC segment", errBadELF)
	}

	stubFileOff := alignUp(uint64(len(so)), maxAlign)
	stubVaddr := alignUp(maxVaddrEnd, maxAlign)

	// Append padding then the entry stub itself.
	so2 := make([]byte, 0, int(stubFileOff)+1024)
	so2 = append(so2, so...)
	if pad := int(stubFileOff) - len(so2); pad > 0 {
		so2 = append(so2, bytes.Repeat([]byte{0}, pad)...)
	}

	stub, err := makeEntryStub(arch, stubVaddr, exportVaddr)
	if err != nil {
		return ArchUnknown, nil, err
	}
	so2 = append(so2, stub...)

	// Convert the selected phdr into our stub PT_LOAD.
	stubPh := phdrs[phIdx]
	stubPh.typ = ptLoad
	stubPh.flags = pfR | pfX
	stubPh.off = stubFileOff
	stubPh.vaddr = stubVaddr
	stubPh.paddr = stubVaddr
	stubPh.filesz = uint64(len(stub))
	stubPh.memsz = uint64(len(stub))
	stubPh.align = maxAlign

	// Patch e_entry to point at the stub.
	writeELF64Entry(so2, stubVaddr)
	writeELF64Phdr(so2, stubPh)

	// Patch DT_FLAGS_1 |= DF_1_PIE if present.
	if err := patchDTFlags1Pie(so2, *dynPh); err != nil {
		return ArchUnknown, nil, err
	}

	return arch, so2, nil
}

func patchDTFlags1Pie(so []byte, dynPh elf64Phdr) error {
	// dynPh.off points to the dynamic entries in the file.
	if dynPh.off+dynPh.filesz > uint64(len(so)) {
		return fmt.Errorf("%w: PT_DYNAMIC outside file", errBadELF)
	}
	dyn := so[dynPh.off : dynPh.off+dynPh.filesz]
	if len(dyn)%16 != 0 {
		// Not fatal; still try to parse what we can.
	}
	for off := 0; off+16 <= len(dyn); off += 16 {
		tag := int64(binary.LittleEndian.Uint64(dyn[off : off+8]))
		val := binary.LittleEndian.Uint64(dyn[off+8 : off+16])
		if tag == dtNull {
			break
		}
		if uint64(tag) == dtFlags1 {
			val |= df1Pie
			binary.LittleEndian.PutUint64(dyn[off+8:off+16], val)
			return nil
		}
	}
	// If there's no DT_FLAGS_1, we still proceed; glibc will treat it as a normal
	// shared object, but for our exec-like jump into ld-linux we primarily need
	// a non-zero e_entry.
	return nil
}

func makeEntryStub(arch Arch, stubVaddr uint64, exportVaddr uint64) ([]byte, error) {
	switch arch {
	case ArchLinuxAMD64:
		return makeStubAMD64(stubVaddr, exportVaddr)
	case ArchLinuxARM64:
		return makeStubARM64(stubVaddr, exportVaddr), nil
	default:
		return nil, fmt.Errorf("unsupported arch %v", arch)
	}
}

func makeStubAMD64(stubVaddr uint64, exportVaddr uint64) ([]byte, error) {
	// call $+5 ; pop rbx ; sub rbx, imm32 ; mov rax, imm64 ; add rax, rbx ; call rax ; exit_group(0)
	//
	// rbx becomes the module base: module_base = (retaddr == stub+5) - (stub_vaddr+5)
	if stubVaddr+5 > 0xffffffff {
		// Keep the encoding simple (sub imm32).
		return nil, fmt.Errorf("stub vaddr too large for amd64 stub encoding")
	}
	b := make([]byte, 0, 64)
	b = append(b,
		0xE8, 0x00, 0x00, 0x00, 0x00, // call $+5
		0x5B,                                     // pop rbx
		0x48, 0x81, 0xEB, 0x00, 0x00, 0x00, 0x00, // sub rbx, imm32
		0x48, 0xB8, // mov rax, imm64
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x48, 0x01, 0xD8, // add rax, rbx
		0xFF, 0xD0, // call rax
		0xB8, 0xE7, 0x00, 0x00, 0x00, // mov eax, 231 (exit_group)
		0x31, 0xFF, // xor edi, edi
		0x0F, 0x05, // syscall
	)
	binary.LittleEndian.PutUint32(b[9:13], uint32(stubVaddr+5))
	binary.LittleEndian.PutUint64(b[15:23], exportVaddr)
	return b, nil
}

func makeMovz64(rd uint32, imm16 uint16, shift uint32) uint32 {
	// MOVZ Xd, #imm16, LSL #shift
	// Encoding: 0xd2800000 | (hw<<21) | (imm16<<5) | rd
	hw := (shift / 16) & 0x3
	return 0xd2800000 | (hw << 21) | (uint32(imm16) << 5) | (rd & 0x1f)
}

func makeMovk64(rd uint32, imm16 uint16, shift uint32) uint32 {
	hw := (shift / 16) & 0x3
	return 0xf2800000 | (hw << 21) | (uint32(imm16) << 5) | (rd & 0x1f)
}

func makeStubARM64(stubVaddr uint64, exportVaddr uint64) []byte {
	// See internal notes in stage0: x19 = stub_start; base = x19 - stub_vaddr.
	// Then call (base + export_vaddr) and exit_group(0).
	const (
		adrX19Dot      = 0x10000013
		subX19X19X20   = 0xcb140273
		addX16X19X20   = 0x8b140270
		blrX16         = 0xd63f0200
		svc0           = 0xd4000001
		rdX0           = 0
		rdX8           = 8
		rdX19          = 19
		rdX20          = 20
		_              = rdX19
		_              = rdX20
		exitGroupSysno = 94
	)

	words := make([]uint32, 0, 32)
	words = append(words, adrX19Dot)

	// x20 = stub_vaddr
	words = append(words,
		makeMovz64(20, uint16(stubVaddr>>0), 0),
		makeMovk64(20, uint16(stubVaddr>>16), 16),
		makeMovk64(20, uint16(stubVaddr>>32), 32),
		makeMovk64(20, uint16(stubVaddr>>48), 48),
	)
	words = append(words, subX19X19X20)

	// x20 = export_vaddr
	words = append(words,
		makeMovz64(20, uint16(exportVaddr>>0), 0),
		makeMovk64(20, uint16(exportVaddr>>16), 16),
		makeMovk64(20, uint16(exportVaddr>>32), 32),
		makeMovk64(20, uint16(exportVaddr>>48), 48),
	)
	words = append(words, addX16X19X20)
	words = append(words, blrX16)

	// exit_group(0)
	words = append(words,
		makeMovz64(rdX8, exitGroupSysno, 0),
		makeMovz64(rdX0, 0, 0),
		svc0,
	)

	b := make([]byte, 0, len(words)*4)
	for _, w := range words {
		var tmp [4]byte
		binary.LittleEndian.PutUint32(tmp[:], w)
		b = append(b, tmp[:]...)
	}
	return b
}
